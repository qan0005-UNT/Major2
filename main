#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

#include "cd.h"
#include "code_exit.h"
#include "path.h"
#include "myhistory.h"
#include "alias.h"
#include "pipeline.h"
#include "signal_control.h"
#include "IO_redirection.h"

#define MAX_LINE 512

void process_line_external(const char *line);

// redirection, piping, cmds
void execute_command(char *line) {
    char *command = strtok(line, ";");
    while (command != NULL) {
        char *trimmed = strdup(command);
        alias_substitute(trimmed);

        // forbuilt-in checks
        char *args[100];
        int argc = 0;
        char *token = strtok(trimmed, " \t\n");
        while (token != NULL && argc < 99) {
            args[argc++] = token;
            token = strtok(NULL, " \t\n");
        }
        args[argc] = NULL;

        if (argc == 0) {
            free(trimmed);
            command = strtok(NULL, ";");
            continue;
        }

        // Built-in commands
        if (strcmp(args[0], "cd") == 0) {
            builtin_cd(args[1]);
        } else if (strcmp(args[0], "exit") == 0) {
            free(trimmed);
            exit(0);
        } else if (strcmp(args[0], "path") == 0) {
            handle_path_command(command);
        } else if (strcmp(args[0], "myhistory") == 0) {
            handle_myhistory(args, argc);
        } else if (strcmp(args[0], "alias") == 0) {
            handle_alias(args, argc);
        } else if (strchr(command, '|')) {
            execute_pipeline(command);
        } else {
            // Fork and exec ex cmd
            pid_t pid = fork();
            if (pid == 0) {
                handle_redirection(args);
                execvp(args[0], args);
                perror("exec failed");
                exit(1);
            } else if (pid < 0) {
                perror("fork failed");
            } else {
                setup_child_process_signal_behavior(pid);
            }
        }

        free(trimmed);
        command = strtok(NULL, ";");
    }
}

void process_line_external(const char *line) {
    char temp[MAX_LINE];
    strncpy(temp, line, sizeof(temp));
    temp[sizeof(temp) - 1] = '\0';
    execute_command(temp);
}

void trim_newline(char *line) {
    size_t len = strlen(line);
    if (len > 0 && line[len - 1] == '\n') {
        line[len - 1] = '\0';
    }
}

int main(int argc, char *argv[]) {
    char line[MAX_LINE];
    FILE *input = stdin;
    int batch_mode = 0;

    if (argc > 2) {
        fprintf(stderr, "Usage: %s [batchFile]\n", argv[0]);
        exit(1);
    } else if (argc == 2) {
        input = fopen(argv[1], "r");
        if (!input) {
            perror("batch file");
            exit(1);
        }
        batch_mode = 1;
    }

    setup_shell_signal_handlers();
    init_history();
    init_alias();

    while (1) {
        if (!batch_mode) {
            printf("newshell> ");
            fflush(stdout);
        }

        if (fgets(line, sizeof(line), input) == NULL) {
            break;
        }

        trim_newline(line);
        if (strlen(line) == 0) continue;

        if (batch_mode) {
            printf("%s\n", line);
        }

        add_history(line);
        execute_command(line);
    }

    if (batch_mode) fclose(input);
    free_path_list();
    return 0;
}
